import os
import re
import time
from collections import Counter

from fmriprep.interfaces.reports import SummaryInterface
from nipype.interfaces.base import (
    BaseInterfaceInputSpec,
    Directory,
    File,
    InputMultiObject,
    InputMultiPath,
    SimpleInterface,
    Str,
    TraitedSpec,
    isdefined,
    traits,
)
from nipype.interfaces.mixins import reporting
from nipype.utils.filemanip import fname_presuffix
from niworkflows.interfaces.reportlets import base as nrb

HEMO_TEMPLATE = """\
\t\t<details open>
\t\t<summary>Summary</summary>
\t\t<ul class="elem-desc">
\t\t\t<li>Mean Lag: {mean_lag}</li>
\t\t\t\t<ul class="elem-desc">
\t\t\t\t<li>lh: {lh_mean_lag}</li>
\t\t\t\t<li>rh: {rh_mean_lag}</li>
\t\t\t\t</ul>
\t\t\t<li>Mean corr: {mean_maxcorr}</li>
\t\t\t<li>Proportion of voxels excluded: {prop_voxel}% ({num_voxels})</li>
\t\t</ul>
\t\t</details>
"""

SESSION_TEMPLATE = """\
\t\t<details open>
\t\t<summary>Summary</summary>
\t\t<ul class="elem-desc">
\t\t\t<li>Number of runs : {n_runs}</li>
\t\t\t<li>Final run length: {final_run}</li>
\t\t</ul>
\t\t</details>
"""


class _ICPlotInputSpecRPT(reporting.ReportCapableInputSpec):
    in_file = File(
        exists=True, mandatory=True, desc="the volume where ROIs are defined"
    )
    in_ICs = File(exists=True, mandatory=True, desc="ICs to be plotted")

    in_ts = File(exists=True, mandatory=True, desc="ts of ICs to be plotted")

    in_mask = File(exists=True, desc="a special region, eg. lesion mask")


class ICPlot(reporting.ReportCapableInterface):
    input_spec = _ICPlotInputSpecRPT
    output_spec = reporting.ReportCapableOutputSpec

    def __init__(self, generate_report=True, **kwargs):
        super().__init__(generate_report=generate_report, **kwargs)

    def _run_interface(self, runtime):
        return runtime

    def _generate_report(self):
        from ..utils.viz import plot_multicomponents

        self._out_report = os.path.abspath(self.inputs.out_report + ".svg")
        fig = plot_multicomponents(
            anat_nii=self.inputs.in_file,
            lesion_nii=self.inputs.in_mask,
            stat_map_nii=self.inputs.in_ICs,
            tseries=self.inputs.in_ts,
        )
        fig.savefig(self._out_report, bbox_inches="tight")


class HemodynamicsSummaryInputSpec(BaseInterfaceInputSpec):
    in_files = InputMultiObject(
        File(exists=True), desc="maps generated by rapidtide"
    )
    corrfit_mask = File(
        exists=True, desc="Mask where correlation was significative"
    )
    brain_mask = File(exists=True, desc="Mask where rapidtide was computed")
    hemi_mask = File(exists=True, desc="Mask for left and right hemispheres")


class HemodynamicsSummary(SummaryInterface):
    input_spec = HemodynamicsSummaryInputSpec

    def _run_interface(self, runtime):
        return super()._run_interface(runtime)

    def _generate_segment(self):
        from ..utils.reports import get_hemoreport

        lagmap = self.inputs.in_files[0]
        corrmap = self.inputs.in_files[1]
        if not isdefined(self.inputs.hemi_mask):
            hemi_mask = None
        else:
            hemi_mask = self.inputs.hemi_mask
        hemo_results = get_hemoreport(
            lagmap=lagmap,
            corrmap=corrmap,
            corrfit_mask=self.inputs.corrfit_mask,
            brain_mask=self.inputs.brain_mask,
            hemimask=hemi_mask,
        )
        return HEMO_TEMPLATE.format(**hemo_results)


class _HemoPlotInputSpecRPT(reporting.ReportCapableInputSpec):
    anat_file = File(exists=True, mandatory=True, desc="T1w image")
    lagmap_file = File(exists=True, mandatory=True, desc="lagmap file to plot")
    roi = File(exists=True, desc="ROI file, lesion")

    label = traits.Str(desc="Label for plot")

    vmax = traits.Float(desc="vmax for plot")


class HemoPlot(reporting.ReportCapableInterface):
    input_spec = _HemoPlotInputSpecRPT
    output_spec = reporting.ReportCapableOutputSpec

    def __init__(self, generate_report=True, **kwargs):
        super().__init__(generate_report=generate_report, **kwargs)

    def _run_interface(self, runtime):
        return runtime

    def _generate_report(self):
        import nibabel as nib
        from niworkflows.viz.utils import compose_view, cuts_from_bbox

        from ..utils.viz import plot_lagmaps

        self._out_report = os.path.abspath(self.inputs.out_report + ".")
        ncuts = 7
        cuts = cuts_from_bbox(nib.load(self.inputs.roi), cuts=ncuts)
        anat = nib.load(self.inputs.anat_file)
        roi = nib.load(self.inputs.roi)
        if isdefined(self.inputs.vmax):
            vmax = self.inputs.vmax
        else:
            vmax = None
        # Call composer
        compose_view(
            plot_lagmaps(
                anat_nii=anat,
                contour=roi,
                stat_map_nii=self.inputs.lagmap_file,
                div_id="Lagmap",
                cuts=cuts,
                order=("z"),
                label=self.inputs.label,
                vmax=vmax,
            ),
            None,
            out_file=self._out_report,
        )


class _RegPlotInputSpecRPT(reporting.ReportCapableInputSpec):
    reference_file = File(
        mandatory=True, desc="Reference image, anatomical image", exists=True
    )
    moving_image = File(mandatory=True, desc="Moving image", exists=True)
    roi = File(exists=True, desc="ROI file, lesion")
    compress_report = traits.Enum(
        "auto",
        True,
        False,
        usedefault=True,
        desc="Compress the reportlet using SVGO or"
        "WEBP. 'auto' - compress if relevant "
        "software is installed, True = force,"
        "False - don't attempt to compress",
    )


class RegisterLesionRPT(nrb.RegistrationRC):
    input_spec = _RegPlotInputSpecRPT
    output_spec = reporting.ReportCapableOutputSpec

    def __init__(self, generate_report=True, **kwargs):
        super().__init__(generate_report=generate_report, **kwargs)

    def _run_interface(self, runtime):
        return runtime

    def _post_run_hook(self, runtime):
        self._fixed_image = self.inputs.reference_file
        self._moving_image = self.inputs.moving_image
        self._contour = self.inputs.roi
        self._out_report = os.path.abspath(self.inputs.out_report + ".svg")
        return super()._post_run_hook(runtime)


class _SessionSummaryInputSpec(BaseInterfaceInputSpec):
    bold_t1 = traits.List(desc="BOLD series from the same session and task")
    concat_bold_t1 = InputMultiObject(File(exists=True), desc="Concatenated BOLD series")


class SessionSummary(SummaryInterface):
    input_spec = _SessionSummaryInputSpec

    def _run_interface(self, runtime):
        return super()._run_interface(runtime)

    def _generate_segment(self):
        import nibabel as nib

        n_runs = len(self.inputs.bold_t1)
        final_length = nib.load(self.inputs.concat_bold_t1[0]).shape[-1]

        return SESSION_TEMPLATE.format(final_run=final_length, n_runs=n_runs)


class _ROIConnPlotInputSpecRPT(reporting.ReportCapableInputSpec):
    input_images = InputMultiPath(
        traits.File(
            mandatory=True,
            desc="Input images to plot",
            exists=True,
        )
    )

    anat_img = traits.File(
        desc="T1w image to plot as a background", exists=True, mandatory=True
    )

    roi = traits.File(desc="ROI mask", exists=True)

    pipeline = InputMultiObject(traits.Str(desc="Denoising pipelines name"))


class ROIConnPlot(reporting.ReportCapableInterface):
    input_spec = _ROIConnPlotInputSpecRPT
    output_spec = reporting.ReportCapableOutputSpec

    def __init__(self, generate_report=True, **kwargs):
        super().__init__(generate_report=generate_report, **kwargs)

    def _run_interface(self, runtime):
        return runtime

    def _generate_report(self):
        from ..utils.viz import plot_multilesionconn

        self._out_report = os.path.abspath(self.inputs.out_report + ".svg")
        fig = plot_multilesionconn(
            anat_nii=self.inputs.anat_img,
            lesion_nii=self.inputs.roi,
            stat_map_nii=self.inputs.input_images,
            titles=self.inputs.pipeline,
        )
        fig.savefig(self._out_report, bbox_inches="tight")
